<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <title>Inbox ‚Äî Audio City</title>
  <link rel="icon" type="image/webp" href="assets/audio-city-logo.webp" />
  <link rel="shortcut icon" type="image/webp" href="assets/audio-city-logo.webp" />
  <link rel="apple-touch-icon" href="assets/audio-city-logo.webp" />
  <script data-cfasync="false">
    // CRITICAL: Check auth state IMMEDIATELY - data-cfasync="false" prevents Cloudflare Rocket Loader from deferring this
    (function() {
      var authCheckLogged = false; // Flag to only log once
      
      function checkAuth() {
        var token = localStorage.getItem('auth_token');
        var userId = localStorage.getItem('user_id');
        var isLoggedIn = !!(token && userId);
        
        // Only log once to reduce console spam
        if (!authCheckLogged) {
          if (isLoggedIn) {
            console.log('üîç [Inbox] Auth check: User logged in');
          }
          // Don't log for guests - it's normal for them not to be logged in
          authCheckLogged = true;
        }
        
        if (isLoggedIn) {
          document.documentElement.classList.add('user-logged-in');
        } else {
          document.documentElement.classList.remove('user-logged-in');
        }
      }
      
      // Run immediately
      checkAuth();
      
      // Run once more after DOM is ready (reduced calls to prevent spam)
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', checkAuth);
      } else {
        setTimeout(checkAuth, 100);
      }
    })();
  </script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
      background: #111;
      color: #fff;
      height: 100vh;
      overflow: hidden;
    }

    /* Header */
    header {
      background: #000;
      padding: 12px 24px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-bottom: 1px solid #222;
      height: 60px;
    }
    
    .logo {
      font-size: 24px;
      font-weight: 900;
      color: #fff;
      text-decoration: none;
    }
    
    nav {
      display: flex;
      gap: 8px;
    }
    
    nav a {
      padding: 8px 16px;
      color: #888;
      text-decoration: none;
      border-radius: 8px;
      font-size: 14px;
    }
    
    nav a:hover, nav a.active {
      color: #fff;
      background: rgba(255,255,255,0.1);
    }

    /* Main Container */
    .container {
      display: flex;
      height: calc(100vh - 60px);
    }

    /* Left Sidebar - Conversations List */
    .sidebar {
      width: 350px;
      background: #111;
      border-right: 1px solid #222;
      display: flex;
      flex-direction: column;
    }

    .sidebar-header {
      padding: 16px;
      border-bottom: 1px solid #222;
      font-size: 20px;
      font-weight: 600;
    }

    .conversations {
      flex: 1;
      overflow-y: auto;
    }

    .conversation-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 16px;
      cursor: pointer;
      border-bottom: 1px solid #1a1a1a;
      transition: background 0.2s;
    }

    .conversation-item:hover {
      background: #1a1a1a;
    }

    .conversation-item.active {
      background: #1f1f1f;
    }

    .conversation-avatar {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: #333;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      flex-shrink: 0;
      overflow: hidden;
    }

    .conversation-avatar img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .conversation-info {
      flex: 1;
      min-width: 0;
    }

    .conversation-name {
      font-weight: 500;
      font-size: 16px;
      margin-bottom: 4px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .conversation-preview {
      color: #888;
      font-size: 14px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .conversation-time {
      color: #666;
      font-size: 12px;
      flex-shrink: 0;
    }

    .unread-badge {
      background: #25d366;
      color: #fff;
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 10px;
      margin-left: 8px;
    }

    /* Right Side - Chat Area */
    .chat-area {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: #0a0a0a;
    }

    /* Chat Header */
    .chat-header {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 16px;
      background: #111;
      border-bottom: 1px solid #222;
      height: 65px;
    }

    .chat-header-avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: #333;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    .chat-header-avatar img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .chat-header-info h3 {
      font-size: 16px;
      font-weight: 500;
    }

    .chat-header-info p {
      font-size: 13px;
      color: #888;
    }
    
    .status-online {
      color: #25d366 !important;
    }
    
    .status-offline {
      color: #888;
    }
    
    .status-indicator {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 6px;
      vertical-align: middle;
    }
    
    .status-indicator.online {
      background: #25d366;
      box-shadow: 0 0 4px rgba(37, 211, 102, 0.5);
    }
    
    .status-indicator.offline {
      background: #666;
    }

    /* Messages Area */
    .messages-area {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .message {
      max-width: 70%;
      padding: 10px 14px;
      border-radius: 18px;
      font-size: 15px;
      line-height: 1.4;
      word-wrap: break-word;
    }

    .message.sent {
      align-self: flex-end;
      background: #25d366;
      color: #fff;
      border-bottom-right-radius: 4px;
    }

    .message.received {
      align-self: flex-start;
      background: #262626;
      color: #fff;
      border-bottom-left-radius: 4px;
    }
    
    .message.new-message {
      animation: messageSlideIn 0.3s ease-out;
    }
    
    @keyframes messageSlideIn {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .message-time {
      font-size: 11px;
      opacity: 0.7;
      margin-top: 4px;
      text-align: right;
    }

    /* Input Area */
    .input-area {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 16px;
      background: #111;
      border-top: 1px solid #222;
    }

    .input-area input {
      flex: 1;
      background: #262626;
      border: none;
      padding: 12px 16px;
      border-radius: 24px;
      color: #fff;
      font-size: 15px;
    }

    .input-area input:focus {
      outline: none;
    }

    .input-area input::placeholder {
      color: #666;
    }

    .send-btn {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      background: #25d366;
      border: none;
      color: #fff;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      transition: background 0.2s;
    }

    .send-btn:hover {
      background: #1da851;
    }

    .send-btn:disabled {
      background: #333;
      cursor: not-allowed;
    }

    /* Empty States */
    .empty-state {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #666;
    }

    .empty-state-icon {
      font-size: 64px;
      margin-bottom: 16px;
    }

    .empty-state-text {
      font-size: 18px;
      margin-bottom: 8px;
    }

    .empty-state-sub {
      font-size: 14px;
      color: #555;
    }

    /* Mobile Responsive */
    @media (max-width: 768px) {
      .sidebar {
        width: 100%;
        display: block;
      }
      
      .chat-area {
        display: none;
        position: fixed;
        top: 60px;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: 100;
      }
      
      .chat-area.active {
        display: flex;
      }
      
      .back-btn {
        display: block;
      }
    }

    .back-btn {
      display: none;
      background: none;
      border: none;
      color: #fff;
      font-size: 24px;
      cursor: pointer;
      padding: 8px;
      margin-right: 8px;
    }

    /* Scrollbar */
    ::-webkit-scrollbar {
      width: 6px;
    }

    ::-webkit-scrollbar-track {
      background: transparent;
    }

    ::-webkit-scrollbar-thumb {
      background: #333;
      border-radius: 3px;
    }
  </style>
</head>
<body>
  <header>
    <a href="index.html" class="logo">AUDIO CITY</a>
    <nav>
      <a href="discover.html">Home</a>
      <a href="feed.html">Feed</a>
      <a href="artists.html">Artists</a>
      <a href="inbox.html" class="active">Inbox</a>
    </nav>
  </header>

  <div class="container">
    <!-- Left: Conversations List -->
    <div class="sidebar">
      <div class="sidebar-header">Messages</div>
      <div class="conversations" id="conversationsList">
        <div class="empty-state">
          <div class="empty-state-icon">üí¨</div>
          <div class="empty-state-text">No conversations yet</div>
          <div class="empty-state-sub">Start chatting with artists!</div>
        </div>
      </div>
    </div>

    <!-- Right: Chat Area -->
    <div class="chat-area" id="chatArea">
      <div class="empty-state" id="noChatSelected">
        <div class="empty-state-icon">üí¨</div>
        <div class="empty-state-text">Select a conversation</div>
        <div class="empty-state-sub">Choose from your messages on the left</div>
      </div>
      
      <!-- Active Chat (hidden by default) -->
      <div id="activeChat" style="display: none; flex-direction: column; height: 100%;">
        <div class="chat-header">
          <button class="back-btn" onclick="closeChat()">‚Üê</button>
          <div class="chat-header-avatar" id="chatAvatar">üë§</div>
          <div class="chat-header-info">
            <h3 id="chatName">User</h3>
            <p id="chatStatus">Online</p>
          </div>
        </div>
        
        <div class="messages-area" id="messagesArea">
          <!-- Messages will be inserted here -->
        </div>
        
        <div class="input-area">
          <input type="text" id="messageInput" placeholder="Type a message..." onkeypress="handleKeyPress(event)">
          <button class="send-btn" id="sendBtn" onclick="sendMessage()">‚û§</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    const API_BASE_URL = (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1')
      ? 'http://localhost:3002'
      : 'https://api.audiocity-ug.com';

    // Check auth - must have BOTH token and user_id
    const authToken = localStorage.getItem('auth_token');
    const userId = localStorage.getItem('user_id');
    let currentUserId = (authToken && userId) ? userId : null;
    let currentChatUserId = null;
    let currentConversationId = null;
    
    // Only log if user is logged in (to reduce console spam for guests)
    if (currentUserId) {
      console.log('üîç [Inbox] Auth check on load: User logged in');
    }

    // Generate conversation ID (sorted for consistency)
    function getConversationId(userId1, userId2) {
      return [userId1, userId2].sort().join('_');
    }

    // Format time
    function formatTime(dateStr) {
      if (!dateStr) return '';
      const date = new Date(dateStr);
      const now = new Date();
      const diff = now - date;
      
      if (diff < 60000) return 'Just now';
      if (diff < 3600000) return Math.floor(diff / 60000) + 'm';
      if (diff < 86400000) return Math.floor(diff / 3600000) + 'h';
      return Math.floor(diff / 86400000) + 'd';
    }

    // Format message time
    function formatMessageTime(dateStr) {
      if (!dateStr) return '';
      const date = new Date(dateStr);
      return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    }

    // Load conversations (with debounce to prevent duplicate calls)
    let isLoadingConversations = false;
    let lastLoadTime = 0;
    const LOAD_DEBOUNCE_MS = 500; // Prevent calls within 500ms of each other
    
    async function loadConversations() {
      // Debounce: prevent rapid duplicate calls
      const now = Date.now();
      if (isLoadingConversations || (now - lastLoadTime < LOAD_DEBOUNCE_MS)) {
        return; // Already loading or too soon
      }
      
      isLoadingConversations = true;
      lastLoadTime = now;
      
      // Re-check auth on every load (in case it changed)
      const authToken = localStorage.getItem('auth_token');
      const userId = localStorage.getItem('user_id');
      currentUserId = (authToken && userId) ? userId : null;
      
      if (!currentUserId) {
        isLoadingConversations = false;
        // Don't log - it's normal for guests to not be logged in
        document.getElementById('conversationsList').innerHTML = `
          <div class="empty-state">
            <div class="empty-state-icon">üîí</div>
            <div class="empty-state-text">Please log in</div>
            <div class="empty-state-sub"><a href="login.html" style="color: #25d366;">Sign in</a> to view messages</div>
          </div>
        `;
        return;
      }
      
      console.log('‚úÖ [Inbox] Auth OK, loading conversations for user:', currentUserId);

      try {
        const res = await fetch(`${API_BASE_URL}/api/users/${currentUserId}/messages`, {
          headers: { 'Authorization': `Bearer ${localStorage.getItem('auth_token')}` }
        });
        
        if (res.ok) {
          const data = await res.json();
          // Ensure data is an array
          const conversations = Array.isArray(data) ? data : [];
          renderConversations(conversations);
        } else {
          renderConversations([]);
        }
      } catch (e) {
        console.error('Error loading conversations:', e);
        renderConversations([]);
      } finally {
        isLoadingConversations = false;
      }
    }

    // Render conversations list
    async function renderConversations(conversations) {
      const container = document.getElementById('conversationsList');
      
      if (!conversations || conversations.length === 0) {
        container.innerHTML = `
          <div class="empty-state">
            <div class="empty-state-icon">üí¨</div>
            <div class="empty-state-text">No conversations yet</div>
            <div class="empty-state-sub">Start chatting with artists!</div>
          </div>
        `;
        return;
      }

      // Group by other user
      const grouped = new Map();
      for (const conv of conversations) {
        // Use other_user_id from API response, or calculate from conversation data
        const otherUserId = conv.other_user_id || (conv.other_user && conv.other_user.id) || conv.id || conv.conversation_id || conv.sender_id;
        if (!otherUserId || otherUserId === currentUserId) continue;
        
        if (!grouped.has(otherUserId)) {
          // Get user info from other_user object (provided by API)
          const otherUser = conv.other_user || {};
          const userName = otherUser.name || otherUser.username || conv.name || conv.sender_name || 'User';
          const userAvatar = otherUser.profile_image_url || otherUser.avatar_url || otherUser.profile_image || conv.avatar || conv.sender_avatar || conv.profile_image_url || null;
          
          // Only show unread if message was received by logged-in user (not sent by them)
          // Check API's is_unread flag, or fallback to checking receiver_id
          const isUnread = conv.is_unread === true || 
            (conv.read === 0 && conv.receiver_id === currentUserId);
          
          // Get last message text (could be in last_message.content or last_message.text)
          const lastMsgObj = conv.last_message || {};
          const lastMsgText = lastMsgObj.content || lastMsgObj.text || conv.text || conv.content || '';
          const lastMsgTime = lastMsgObj.created_at || conv.last_message_at || conv.created_at || conv.updated_at || '';
          
          grouped.set(otherUserId, {
            otherId: otherUserId,
            lastMessage: lastMsgText,
            lastTime: lastMsgTime,
            unread: isUnread,
            unreadCount: conv.unread_count || (isUnread ? 1 : 0),
            name: userName,
            avatar: userAvatar
          });
        }
      }

      // Fetch user info for conversations that don't have it yet
      const items = [];
      for (const [userId, conv] of grouped) {
        // Only fetch if name is still missing or is the fallback 'User'
        if (!conv.name || conv.name === 'User' || !conv.avatar) {
          try {
            const userRes = await fetch(`${API_BASE_URL}/api/users/${userId}`);
            if (userRes.ok) {
              const userData = await userRes.json();
              // Use name from API if we don't have a good one
              if (!conv.name || conv.name === 'User') {
                conv.name = userData.name || userData.full_name || userData.username || userData.display_name || 'User';
              }
              // Use avatar from API if we don't have one
              if (!conv.avatar) {
                let avatarUrl = userData.profile_image_url || userData.avatar_url || userData.profile_image || userData.avatar || null;
                if (avatarUrl && avatarUrl.startsWith('http://')) {
                  avatarUrl = avatarUrl.replace('http://', 'https://');
                }
                conv.avatar = avatarUrl;
              }
            }
          } catch (e) {
            console.error('Error loading user info for conversation:', e);
            if (!conv.name || conv.name === 'User') {
              conv.name = 'User';
            }
          }
        }
        items.push({ otherId: userId, ...conv });
      }

      // Sort by last message time
      items.sort((a, b) => new Date(b.lastTime || 0) - new Date(a.lastTime || 0));

      container.innerHTML = items.map(conv => {
        const avatarHtml = conv.avatar 
          ? `<img src="${conv.avatar}" alt="${escapeHtml(conv.name || 'User')}" onerror="this.parentElement.innerHTML='üë§'">` 
          : 'üë§';
        return `
        <div class="conversation-item" data-user-id="${conv.otherId}" onclick="openChat('${conv.otherId}', event)">
          <div class="conversation-avatar">
            ${avatarHtml}
          </div>
          <div class="conversation-info">
            <div class="conversation-name">${escapeHtml(conv.name || 'User')}</div>
            <div class="conversation-preview">${escapeHtml(conv.lastMessage || 'No messages')}</div>
          </div>
          <div style="text-align: right;">
            <div class="conversation-time">${formatTime(conv.lastTime)}</div>
            ${conv.unread && conv.unreadCount > 0 ? `<span class="unread-badge">${conv.unreadCount > 99 ? '99+' : conv.unreadCount}</span>` : ''}
          </div>
        </div>
      `;
      }).join('');
    }

    // Open chat with user
    async function openChat(userId, clickEvent) {
      if (!userId) {
        console.error('No user ID provided to openChat');
        return;
      }
      
      currentChatUserId = userId;
      currentConversationId = getConversationId(currentUserId, userId);

      // Show chat UI
      document.getElementById('noChatSelected').style.display = 'none';
      document.getElementById('activeChat').style.display = 'flex';
      document.getElementById('chatArea').classList.add('active');

      // Mark conversation as active
      document.querySelectorAll('.conversation-item').forEach(el => el.classList.remove('active'));
      if (clickEvent && clickEvent.target && clickEvent.target.closest) {
        clickEvent.target.closest('.conversation-item')?.classList.add('active');
      } else {
        // Find and highlight the conversation item by user ID
        const convItem = document.querySelector(`.conversation-item[data-user-id="${userId}"]`);
        if (convItem) convItem.classList.add('active');
      }

      // Set loading state
      document.getElementById('chatName').textContent = 'Loading...';
      document.getElementById('chatAvatar').innerHTML = 'üë§';

      // Load user info
      try {
        console.log('Fetching user data for:', userId);
        const res = await fetch(`${API_BASE_URL}/api/users/${userId}`);
        console.log('User API response status:', res.status);
        
        if (res.ok) {
          const user = await res.json();
          console.log('Loaded user data:', user);
          console.log('Available fields:', Object.keys(user));
          
          // Try all possible name fields (check in order of preference)
          const userName = user.name || user.full_name || user.display_name || user.username || 'User';
          console.log('Selected user name:', userName);
          document.getElementById('chatName').textContent = userName;
          
          // Try all possible avatar fields and force HTTPS
          const avatar = document.getElementById('chatAvatar');
          let avatarUrl = user.profile_image_url || user.avatar_url || user.profile_image || user.avatar || null;
          console.log('Avatar URL:', avatarUrl);
          
          if (avatarUrl) {
            // Force HTTPS for avatar URLs
            if (avatarUrl.startsWith('http://')) {
              avatarUrl = avatarUrl.replace('http://', 'https://');
            }
            avatar.innerHTML = `<img src="${avatarUrl}" alt="${userName}" style="width: 100%; height: 100%; object-fit: cover; border-radius: 50%;" onerror="console.error('Avatar load failed'); this.parentElement.innerHTML='üë§'">`;
          } else {
            console.log('No avatar URL found for user');
            avatar.innerHTML = 'üë§';
          }
          
        } else {
          const errorText = await res.text();
          console.error('Failed to load user:', res.status, res.statusText, errorText);
          document.getElementById('chatName').textContent = 'User';
        }
      } catch (e) {
        console.error('Error loading user:', e);
        document.getElementById('chatName').textContent = 'User';
      }

      // Update online status immediately and start polling
      updateOnlineStatus(userId);
      // Restart status updates for new chat
      if (onlineStatusInterval) {
        clearInterval(onlineStatusInterval);
      }
      onlineStatusInterval = setInterval(() => {
        if (currentChatUserId) {
          updateOnlineStatus(currentChatUserId);
        }
      }, 5000);

      // Reset message tracking for new chat
      lastMessageCount = 0;
      lastMessageIds.clear();

      // Load messages
      await loadMessages();
      
      // Restart message polling for this chat
      startMessagePolling();

      // Mark as read
      try {
        await fetch(`${API_BASE_URL}/api/conversations/${currentUserId}/${userId}/messages/read`, {
          method: 'PUT',
          headers: { 'Authorization': `Bearer ${localStorage.getItem('auth_token')}` }
        });
      } catch (e) {}
    }

    // Close chat (mobile)
    function closeChat() {
      document.getElementById('noChatSelected').style.display = 'flex';
      document.getElementById('activeChat').style.display = 'none';
      document.getElementById('chatArea').classList.remove('active');
      currentChatUserId = null;
    }

    // Load messages for current chat
    async function loadMessages() {
      if (!currentChatUserId) return;

      const container = document.getElementById('messagesArea');
      
      try {
        const res = await fetch(`${API_BASE_URL}/api/conversations/${currentUserId}/${currentChatUserId}/messages`, {
          headers: { 'Authorization': `Bearer ${localStorage.getItem('auth_token')}` }
        });

        if (res.ok) {
          const messagesData = await res.json();
          // Ensure messages is an array
          const messages = Array.isArray(messagesData) ? messagesData : [];
          renderMessages(messages);
        } else {
          container.innerHTML = '<div class="empty-state"><div class="empty-state-icon">üí¨</div><div class="empty-state-text">Start the conversation!</div></div>';
        }
      } catch (e) {
        console.error('Error loading messages:', e);
        container.innerHTML = '<div class="empty-state"><div class="empty-state-icon">‚ö†Ô∏è</div><div class="empty-state-text">Error loading messages</div></div>';
      }
    }

    // Track last message count to detect new messages
    let lastMessageCount = 0;
    let lastMessageIds = new Set();
    
    // Render messages
    function renderMessages(messages, isNewMessage = false) {
      const container = document.getElementById('messagesArea');

      if (!messages || messages.length === 0) {
        container.innerHTML = '<div class="empty-state"><div class="empty-state-icon">üí¨</div><div class="empty-state-text">Start the conversation!</div></div>';
        lastMessageCount = 0;
        lastMessageIds.clear();
        return;
      }

      // Sort by time
      const sorted = [...messages].sort((a, b) => 
        new Date(a.created_at || 0) - new Date(b.created_at || 0)
      );

      // Detect new messages
      const currentMessageIds = new Set(sorted.map(m => m.id || m.created_at));
      const newMessages = sorted.filter(m => {
        const msgId = m.id || m.created_at;
        return !lastMessageIds.has(msgId) && (m.sender_id || m.senderId) !== currentUserId;
      });

      // Update last message tracking
      lastMessageCount = sorted.length;
      lastMessageIds = currentMessageIds;

      // Show notification for new messages if not in active chat or page is hidden
      if (newMessages.length > 0) {
        // Show browser notification if page is hidden or chat is not open
        if (!currentChatUserId || document.hidden) {
          // Get sender info for notification
          const newMsg = newMessages[0];
          if (newMsg.sender_id) {
            fetch(`${API_BASE_URL}/api/users/${newMsg.sender_id}`)
              .then(res => res.json())
              .then(user => {
                showMessageNotification({
                  ...newMsg,
                  sender_name: user.name || user.username || 'Someone',
                  sender_avatar: user.profile_image_url || user.avatar_url
                });
              })
              .catch(() => {
                showMessageNotification(newMsg);
              });
          } else {
            showMessageNotification(newMsg);
          }
        }
        
        // Play sound for new received messages (only if chat is open and page is visible)
        if (currentChatUserId && !document.hidden) {
          playNotificationSound();
        }
      }

      container.innerHTML = sorted.map(msg => {
        const isSent = (msg.sender_id || msg.senderId) === currentUserId;
        const content = msg.content || msg.text || msg.message || '';
        const time = formatMessageTime(msg.created_at);
        const isNew = newMessages.some(m => (m.id || m.created_at) === (msg.id || msg.created_at));

        return `
          <div class="message ${isSent ? 'sent' : 'received'} ${isNew ? 'new-message' : ''}" data-message-id="${msg.id || msg.created_at}">
            <div>${escapeHtml(content)}</div>
            <div class="message-time">${time}</div>
          </div>
        `;
      }).join('');

      // Scroll to bottom if new message or user is at bottom
      const wasAtBottom = container.scrollHeight - container.scrollTop <= container.clientHeight + 100;
      if (isNewMessage || wasAtBottom) {
        container.scrollTop = container.scrollHeight;
      }
    }

    // Send message
    async function sendMessage() {
      const input = document.getElementById('messageInput');
      const text = input.value.trim();
      
      if (!text || !currentChatUserId) return;

      const sendBtn = document.getElementById('sendBtn');
      sendBtn.disabled = true;

      try {
        const res = await fetch(`${API_BASE_URL}/api/conversations/${currentUserId}/${currentChatUserId}/messages`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${localStorage.getItem('auth_token')}`
          },
          body: JSON.stringify({
            sender_id: currentUserId,
            recipient_id: currentChatUserId,
            content: text
          })
        });

        if (res.ok) {
          input.value = '';
          await loadMessages();
          loadConversations(); // Update sidebar
        } else {
          const err = await res.json().catch(() => ({}));
          alert('Failed to send: ' + (err.error || 'Unknown error'));
        }
      } catch (e) {
        console.error('Error sending:', e);
        alert('Error sending message');
      } finally {
        sendBtn.disabled = false;
      }
    }

    // Handle Enter key
    function handleKeyPress(e) {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    }

    // Escape HTML
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text || '';
      return div.innerHTML;
    }

    // Check URL params
    function checkUrlParams() {
      const params = new URLSearchParams(window.location.search);
      const userId = params.get('user');
      if (userId) {
        openChat(userId);
      }
    }

    // Update online status for current chat user
    let onlineStatusInterval = null;
    
    async function updateOnlineStatus(userId) {
      if (!userId) return;
      
      try {
        const res = await fetch(`${API_BASE_URL}/api/users/${userId}/online`);
        if (res.ok) {
          const data = await res.json();
          const statusEl = document.getElementById('chatStatus');
          if (statusEl) {
            if (data.is_online) {
              statusEl.innerHTML = '<span class="status-indicator online"></span>Online';
              statusEl.className = 'status-online';
            } else {
              const minutesAgo = data.minutes_ago || 0;
              let statusText = 'Offline';
              if (minutesAgo > 0 && minutesAgo < 60) {
                statusText = `Offline (${minutesAgo}m ago)`;
              } else if (minutesAgo >= 60 && minutesAgo < 1440) {
                const hoursAgo = Math.floor(minutesAgo / 60);
                statusText = `Offline (${hoursAgo}h ago)`;
              } else if (minutesAgo >= 1440) {
                const daysAgo = Math.floor(minutesAgo / 1440);
                statusText = `Offline (${daysAgo}d ago)`;
              }
              statusEl.innerHTML = `<span class="status-indicator offline"></span>${statusText}`;
              statusEl.className = 'status-offline';
            }
          }
        }
      } catch (e) {
        console.error('Error checking online status:', e);
      }
    }
    
    // Send heartbeat to keep current user online
    function sendHeartbeat() {
      if (!currentUserId) return;
      
      fetch(`${API_BASE_URL}/api/users/${currentUserId}/online`, {
        method: 'POST',
        headers: { 'Authorization': `Bearer ${localStorage.getItem('auth_token')}` }
      }).catch(e => console.error('Heartbeat error:', e));
    }
    
    // Start heartbeat (every 2 minutes) and status polling
    function startStatusUpdates() {
      // Send heartbeat immediately
      sendHeartbeat();
      // Then every 2 minutes
      setInterval(sendHeartbeat, 120000);
    }
    
    // Request notification permission
    function requestNotificationPermission() {
      if ('Notification' in window && Notification.permission === 'default') {
        Notification.requestPermission();
      }
    }
    
    // Show browser notification for new message
    function showMessageNotification(message) {
      if (!('Notification' in window)) return;
      
      if (Notification.permission === 'granted') {
        const senderName = message.sender_name || message.name || 'Someone';
        const content = message.content || message.text || message.message || 'New message';
        
        const notification = new Notification(`${senderName} sent a message`, {
          body: content.length > 100 ? content.substring(0, 100) + '...' : content,
          icon: message.sender_avatar || message.avatar || '/favicon.ico',
          tag: `message-${message.sender_id || message.id}`,
          requireInteraction: false
        });
        
        notification.onclick = () => {
          window.focus();
          if (message.sender_id) {
            openChat(message.sender_id);
          }
          notification.close();
        };
        
        // Auto-close after 5 seconds
        setTimeout(() => notification.close(), 5000);
      }
    }
    
    // Play notification sound
    function playNotificationSound() {
      try {
        // Create a simple beep sound using Web Audio API
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.frequency.value = 800;
        oscillator.type = 'sine';
        
        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
        
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.2);
      } catch (e) {
        console.log('Could not play notification sound:', e);
      }
    }
    
    // Poll for new messages
    let messagePollInterval = null;
    let conversationPollInterval = null;
    
    function startMessagePolling() {
      // Poll for new messages in active chat (every 3 seconds)
      if (messagePollInterval) {
        clearInterval(messagePollInterval);
      }
      messagePollInterval = setInterval(async () => {
        if (currentChatUserId && currentUserId) {
          try {
            const res = await fetch(`${API_BASE_URL}/api/conversations/${currentUserId}/${currentChatUserId}/messages`, {
              headers: { 'Authorization': `Bearer ${localStorage.getItem('auth_token')}` }
            });
            
            if (res.ok) {
              const messagesData = await res.json();
              const messages = Array.isArray(messagesData) ? messagesData : [];
              
              // Only update if message count changed
              if (messages.length !== lastMessageCount) {
                renderMessages(messages, true);
              }
            }
          } catch (e) {
            console.error('Error polling messages:', e);
          }
        }
      }, 3000);
      
      // Poll for new conversations (every 5 seconds)
      if (conversationPollInterval) {
        clearInterval(conversationPollInterval);
      }
      conversationPollInterval = setInterval(() => {
        if (currentUserId && document.visibilityState === 'visible') {
          loadConversations();
        }
      }, 5000);
    }
    
    function stopMessagePolling() {
      if (messagePollInterval) {
        clearInterval(messagePollInterval);
        messagePollInterval = null;
      }
      if (conversationPollInterval) {
        clearInterval(conversationPollInterval);
        conversationPollInterval = null;
      }
    }

    // Initialize
    let isInitialized = false;
    document.addEventListener('DOMContentLoaded', () => {
      // Prevent multiple initializations
      if (isInitialized) return;
      isInitialized = true;
      
      loadConversations();
      checkUrlParams();
      startStatusUpdates();
      requestNotificationPermission();
      startMessagePolling();
      
      // Request notification permission when user interacts
      document.addEventListener('click', requestNotificationPermission, { once: true });
      
      // Pause polling when page is hidden, resume when visible
      document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'visible') {
          loadConversations(); // Refresh immediately when page becomes visible
          startMessagePolling();
        } else {
          stopMessagePolling();
        }
      });
    });
  </script>
</body>
</html>
